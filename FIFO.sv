//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.4.11
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Dut ()
//
module Dut // "top.dut"
(
    input logic clk,
    input logic nrst,
    input logic [31:0] in,
    output logic [31:0] out
);

// Variables generated for SystemC signals
logic fifo_push_sig;
logic [31:0] fifo_data_in_sig;
logic fifo_ready_sig;
logic fifo_pop_sig;
logic [31:0] fifo_data_out_sig;
logic fifo_valid_sig;
logic fifo_full_sig;
logic fifo_clk;
logic fifo_nrst;

// Assignments generated for C++ channel arrays
assign fifo_clk = clk;
assign fifo_nrst = nrst;

//------------------------------------------------------------------------------
// Clocked THREAD: reqProc (example.cpp:29:5) 

// Thread-local variables
logic [31:0] fifo_data_in_sig_next;
logic fifo_push_sig_next;

// Next-state combinational logic
always_comb begin : reqProc_comb     // example.cpp:29:5
    reqProc_func;
end
function void reqProc_func;
    logic TMP_0;
    logic TMP_1;
    logic push;
    fifo_data_in_sig_next = fifo_data_in_sig;
    fifo_push_sig_next = fifo_push_sig;
    // Call ready() begin
    TMP_0 = fifo_ready_sig;
    // Call ready() end
    if (TMP_0)
    begin
        push = 1;
        // Call push() begin
        fifo_data_in_sig_next = in;
        fifo_push_sig_next = push;
        TMP_1 = fifo_ready_sig;
        // Call push() end
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : reqProc_ff
    if ( ~nrst ) begin
    end
    else begin
        fifo_data_in_sig <= fifo_data_in_sig_next;
        fifo_push_sig <= fifo_push_sig_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: respProc (example.cpp:40:5) 

// Thread-local variables
logic fifo_pop_sig_next;
logic [31:0] out_next;

// Next-state combinational logic
always_comb begin : respProc_comb     // example.cpp:40:5
    respProc_func;
end
function void respProc_func;
    logic TMP_0;
    logic [31:0] TMP_1;
    logic pop;
    fifo_pop_sig_next = fifo_pop_sig;
    out_next = out;
    // Call valid() begin
    TMP_0 = fifo_valid_sig;
    // Call valid() end
    if (TMP_0)
    begin
        pop = 1;
        // Call pop() begin
        fifo_pop_sig_next = pop;
        TMP_1 = 32'(fifo_data_out_sig);
        // Call pop() end
        out_next = TMP_1;
    end
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : respProc_ff
    if ( ~nrst ) begin
    end
    else begin
        fifo_pop_sig <= fifo_pop_sig_next;
        out <= out_next;
    end
end


//------------------------------------------------------------------------------
// Child module instances

adv_fifo fifo_fifo
(
  .clk(fifo_clk),
  .nrst(fifo_nrst),
  .push(fifo_push_sig),
  .data_in(fifo_data_in_sig),
  .ready_to_push(fifo_ready_sig),
  .pop(fifo_pop_sig),
  .data_out(fifo_data_out_sig),
  .out_valid(fifo_valid_sig),
  .almost_full(fifo_full_sig)
);

endmodule



//==============================================================================
//
// Module: adv_fifo (AdvFifo.h:424:5)
//
module adv_fifo // "top.dut.fifo.fifofifo"
(
    input logic clk,
    input logic nrst,
    input logic push,
    input logic [31:0] data_in,
    output logic ready_to_push,
    input logic pop,
    output logic [31:0] data_out,
    output logic out_valid,
    output logic almost_full
);

// Variables generated for SystemC signals
logic [31:0] pop_data;
logic [3:0] element_num;
logic [3:0] element_num_d;
logic push_sig;
logic pop_enable;
logic push_enable;
logic pop_enable_sig;
logic push_enable_sig;
logic [31:0] mcp_data_reg;
logic mcp_valid_reg;
logic out_valid_reg;
logic ready_push_reg;
logic almost_full_reg;

//------------------------------------------------------------------------------
// Method process: asyncProc (AdvFifo.h:176:5) 

always_comb 
begin : asyncProc     // AdvFifo.h:176:5
    if (!out_valid_reg)
    begin
        if (pop_enable_sig)
        begin
            data_out = data_in;
            out_valid = push;
            push_sig = push && !pop;
        end else begin
            out_valid = mcp_valid_reg;
            data_out = mcp_data_reg;
            push_sig = push;
        end
    end else begin
        out_valid = 1;
        data_out = pop_data;
        push_sig = push;
    end
    if (push_enable_sig)
    begin
        ready_to_push = pop && pop_enable && out_valid_reg || ready_push_reg;
    end else begin
        ready_to_push = ready_push_reg;
    end
    almost_full = almost_full_reg || (push && !pop && element_num == 6 - 3 - 1);
end

//------------------------------------------------------------------------------
// Clocked THREAD: syncProc (AdvFifo.h:260:5) 

// Thread-local variables
logic [3:0] element_num_next;
logic [3:0] element_num_d_next;
logic out_valid_reg_next;
logic almost_full_reg_next;
logic ready_push_reg_next;
logic pop_enable_sig_next;
logic push_enable_sig_next;
logic mcp_valid_reg_next;
logic [31:0] mcp_data_reg_next;
logic [31:0] pop_data_next;
logic [2:0] popIndx;
logic [2:0] popIndx_next;
logic [3:0] elementNum;
logic [3:0] elementNum_next;
logic [2:0] pushIndx;
logic [2:0] pushIndx_next;
logic [31:0] fifo_buffer_flat[6];
logic [31:0] fifo_buffer_flat_next[6];

// Next-state combinational logic
always_comb begin : syncProc_comb     // AdvFifo.h:260:5
    syncProc_func;
end
function void syncProc_func;
    almost_full_reg_next = almost_full_reg;
    elementNum_next = elementNum;
    element_num_d_next = element_num_d;
    element_num_next = element_num;
    fifo_buffer_flat_next = fifo_buffer_flat;
    mcp_data_reg_next = mcp_data_reg;
    mcp_valid_reg_next = mcp_valid_reg;
    out_valid_reg_next = out_valid_reg;
    popIndx_next = popIndx;
    pop_data_next = pop_data;
    pop_enable_sig_next = pop_enable_sig;
    pushIndx_next = pushIndx;
    push_enable_sig_next = push_enable_sig;
    ready_push_reg_next = ready_push_reg;
    pop_enable_sig_next = pop_enable;
    push_enable_sig_next = push_enable;
    mcp_valid_reg_next = out_valid;
    mcp_data_reg_next = data_out;
    ready_push_reg_next = ready_to_push;
    if (pop && pop_enable && out_valid_reg)
    begin
        if (popIndx_next == 6 - 1)
        begin
            popIndx_next = 0;
        end else begin
            popIndx_next = popIndx_next + 1;
        end
        elementNum_next = elementNum_next - 1;
    end
    if (push_sig && ready_to_push)
    begin
        fifo_buffer_flat_next[pushIndx_next] = data_in;
        if (pushIndx_next == 6 - 1)
        begin
            pushIndx_next = 0;
        end else begin
            pushIndx_next = pushIndx_next + 1;
        end
        elementNum_next = elementNum_next + 1;
    end
    pop_data_next = fifo_buffer_flat_next[popIndx_next];
    if (push_enable)
    begin
        almost_full_reg_next = elementNum_next > 6 - 3 - 1;
        ready_push_reg_next = elementNum_next != 6;
    end
    if (pop_enable)
    begin
        element_num_next = elementNum_next;
        out_valid_reg_next = elementNum_next != 0;
    end
    element_num_d_next = element_num;
endfunction

// Syncrhonous register update
always_ff @(posedge clk or negedge nrst) 
begin : syncProc_ff
    if ( ~nrst ) begin
        element_num <= 0;
        element_num_d <= 0;
        out_valid_reg <= 0;
        almost_full_reg <= 0;
        ready_push_reg <= 0;
        pop_enable_sig <= 1;
        push_enable_sig <= 1;
        mcp_valid_reg <= 0;
        mcp_data_reg <= 0;
        elementNum <= 0;
        popIndx <= 0;
        pushIndx <= 0;
        pop_data <= 0;
        fifo_buffer_flat[0] <= 32'd0;
        for (integer i = 1; i < 6; i++)
        begin
            fifo_buffer_flat[i] <= 32'd0;
        end
    end
    else begin
        element_num <= element_num_next;
        element_num_d <= element_num_d_next;
        out_valid_reg <= out_valid_reg_next;
        almost_full_reg <= almost_full_reg_next;
        ready_push_reg <= ready_push_reg_next;
        pop_enable_sig <= pop_enable_sig_next;
        push_enable_sig <= push_enable_sig_next;
        mcp_valid_reg <= mcp_valid_reg_next;
        mcp_data_reg <= mcp_data_reg_next;
        pop_data <= pop_data_next;
        popIndx <= popIndx_next;
        elementNum <= elementNum_next;
        pushIndx <= pushIndx_next;
        fifo_buffer_flat <= fifo_buffer_flat_next;
    end
end

//------------------------------------------------------------------------------
// Method process: setEnableProc (AdvFifo.h:400:5) 

assign pop_enable = 1;
assign push_enable = 1;

`ifndef INTEL_SVA_OFF
sctAssertLine165 : assert property (
    @(posedge clk) push && !ready_to_push && (!pop || !out_valid) |=> ready_to_push );
sctAssertLine168 : assert property (
    @(posedge clk) element_num == 6 |-> almost_full && !ready_to_push );
sctAssertLine171 : assert property (
    @(posedge clk) push && ready_to_push && pop && out_valid |=> element_num == element_num_d );
sctAssertLine174 : assert property (
    @(posedge clk) (!push || !ready_to_push) && pop && out_valid |=> element_num == element_num_d - 1 );
`endif // INTEL_SVA_OFF

endmodule


